{"ast":null,"code":"var _jsxFileName = \"/Users/swarnim/Desktop/boggle_app-master/src/extra.js\";\nimport React, { Component } from \"react\";\nimport { word_list } from \"./word_list\";\n\nclass FindAllValidWords extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {};\n  }\n\n  visited_node(n, visited_nodes) {\n    for (var i = 0; i < n; i++) {\n      var row = [];\n\n      for (var j = 0; j < n; j++) {\n        row.push(false);\n      }\n\n      visited_nodes.push(row);\n    }\n  }\n\n  check_for_letter_traversal(grid, word, matched_letter, x, y, visited_nodes, answer) {\n    for (var i = x - 1; i < x + 2; i++) {\n      for (var j = y - 1; j < y + 2; j++) {\n        if (i >= 0 && j >= 0 && i < grid.length && j < grid.length && visited_nodes[i][j] === false) {\n          if (word[matched_letter] === grid[i][j]) {\n            if (word.length - matched_letter === 1) {\n              answer.push(word);\n              return true;\n            } else {\n              matched_letter += 1;\n              visited_nodes[i][j] = true;\n\n              if (this.check_for_letter_traversal(grid, word, matched_letter, i, j, visited_nodes, answer)) {\n                return true;\n              }\n\n              matched_letter -= 1;\n              visited_nodes[i][j] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  grid_contains_all_unique_letters(word, first_letter_map) {\n    for (var i = 0; i < word.length; i++) {\n      if (!first_letter_map.has(word[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  boggle(grid, dictionary) {\n    var answer = [];\n    var n = grid.length;\n    var first_letter_map = new Map();\n    var boggle_call = 0;\n    console.log(grid, first_letter_map);\n\n    for (var i = 0; i < grid.length; i++) {\n      for (var j = 0; j < grid.length; j++) {\n        var letter = grid[i][j];\n\n        if (!first_letter_map.has(letter)) {\n          first_letter_map.set(letter, [[i, j]]);\n        } else {\n          first_letter_map.get(letter).push([i, j]);\n        }\n      }\n    }\n\n    console.log(first_letter_map, \"maka\");\n    var a = 0;\n\n    while (a < dictionary.length) {\n      var word = dictionary[a].toUpperCase();\n      var start_position = [];\n      var skip_by = 8192;\n\n      if (!first_letter_map.has(word[0])) {\n        console.log(a, \"the sahi word\", dictionary[a].toUpperCase());\n\n        while (skip_by >= 1) {\n          if (a + skip_by < dictionary.length && word[0] === dictionary[a + skip_by][0].toUpperCase()) {\n            console.log(a, \"the sahi main word\", dictionary[a].toUpperCase());\n            console.log();\n            a = a + skip_by;\n          } else {\n            console.log(a, \"reducing skip_by\", dictionary[a].toUpperCase());\n            skip_by = skip_by / 2;\n          }\n        }\n\n        a++;\n        continue;\n      } else {\n        if (!this.grid_contains_all_unique_letters(word, first_letter_map)) {\n          a++;\n          continue;\n        }\n\n        start_position = first_letter_map.get(word[0]);\n        console.log(a, \"word\", word);\n\n        for (var i = 0; i < start_position.length; i++) {\n          if (answer.includes(word)) {\n            break;\n          }\n\n          boggle_call++;\n          var visited_nodes = [];\n          this.visited_node(n, visited_nodes);\n          var element = start_position[i];\n          visited_nodes[element[0]][element[1]] = true;\n          this.check_for_letter_traversal(grid, word, 1, element[0], element[1], visited_nodes, answer);\n        }\n      }\n\n      a++;\n    }\n\n    console.log(boggle_call, \"boggle_call\");\n    return answer;\n  }\n\n  render() {\n    var word_valid_list = this.boggle([[\"T\", \"T\", \"N\", \"T\", \"D\"], [\"H\", \"N\", \"C\", \"P\", \"R\"], [\"I\", \"L\", \"A\", \"E\", \"E\"], [\"G\", \"L\", \"Z\", \"R\", \"E\"], [\"S\", \"R\", \"F\", \"O\", \"S\"]], word_list);\n    console.log(word_valid_list);\n    return React.createElement(\"h1\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 165\n      },\n      __self: this\n    }, \"My name is Swarnim\");\n  }\n\n}\n\nexport default FindAllValidWords;","map":{"version":3,"sources":["/Users/swarnim/Desktop/boggle_app-master/src/extra.js"],"names":["React","Component","word_list","FindAllValidWords","state","visited_node","n","visited_nodes","i","row","j","push","check_for_letter_traversal","grid","word","matched_letter","x","y","answer","length","grid_contains_all_unique_letters","first_letter_map","has","boggle","dictionary","Map","boggle_call","console","log","letter","set","get","a","toUpperCase","start_position","skip_by","includes","element","render","word_valid_list"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport { word_list } from \"./word_list\";\n\nclass FindAllValidWords extends Component {\n  state = {};\n\n  visited_node(n, visited_nodes) {\n    for (var i = 0; i < n; i++) {\n      var row = [];\n      for (var j = 0; j < n; j++) {\n        row.push(false);\n      }\n      visited_nodes.push(row);\n    }\n  }\n\n  check_for_letter_traversal(\n    grid,\n    word,\n    matched_letter,\n    x,\n    y,\n    visited_nodes,\n    answer\n  ) {\n    for (var i = x - 1; i < x + 2; i++) {\n      for (var j = y - 1; j < y + 2; j++) {\n        if (\n          i >= 0 &&\n          j >= 0 &&\n          i < grid.length &&\n          j < grid.length &&\n          visited_nodes[i][j] === false\n        ) {\n          if (word[matched_letter] === grid[i][j]) {\n            if (word.length - matched_letter === 1) {\n              answer.push(word);\n              return true;\n            } else {\n              matched_letter += 1;\n              visited_nodes[i][j] = true;\n              if (\n                this.check_for_letter_traversal(\n                  grid,\n                  word,\n                  matched_letter,\n                  i,\n                  j,\n                  visited_nodes,\n                  answer\n                )\n              ) {\n                return true;\n              }\n              matched_letter -= 1;\n              visited_nodes[i][j] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  grid_contains_all_unique_letters(word, first_letter_map) {\n    for (var i = 0; i < word.length; i++) {\n      if (!first_letter_map.has(word[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  boggle(grid, dictionary) {\n    var answer = [];\n    var n = grid.length;\n    var first_letter_map = new Map();\n    var boggle_call = 0;\n\n    console.log(grid, first_letter_map);\n\n    for (var i = 0; i < grid.length; i++) {\n      for (var j = 0; j < grid.length; j++) {\n        var letter = grid[i][j];\n        if (!first_letter_map.has(letter)) {\n          first_letter_map.set(letter, [[i, j]]);\n        } else {\n          first_letter_map.get(letter).push([i, j]);\n        }\n      }\n    }\n\n    console.log(first_letter_map, \"maka\");\n    var a = 0;\n\n    while (a < dictionary.length) {\n      var word = dictionary[a].toUpperCase();\n      var start_position = [];\n\n      var skip_by = 8192;\n\n      if (!first_letter_map.has(word[0])) {\n        console.log(a, \"the sahi word\", dictionary[a].toUpperCase());\n        while (skip_by >= 1) {\n          if (\n            a + skip_by < dictionary.length &&\n            word[0] === dictionary[a + skip_by][0].toUpperCase()\n          ) {\n            console.log(a, \"the sahi main word\", dictionary[a].toUpperCase());\n            console.log();\n            a = a + skip_by;\n          } else {\n            console.log(a, \"reducing skip_by\", dictionary[a].toUpperCase());\n            skip_by = skip_by / 2;\n          }\n        }\n        a++;\n        continue;\n      } else {\n        if (!this.grid_contains_all_unique_letters(word, first_letter_map)) {\n          a++;\n          continue;\n        }\n\n        start_position = first_letter_map.get(word[0]);\n        console.log(a, \"word\", word);\n\n        for (var i = 0; i < start_position.length; i++) {\n          if (answer.includes(word)) {\n            break;\n          }\n          boggle_call++;\n          var visited_nodes = [];\n          this.visited_node(n, visited_nodes);\n          var element = start_position[i];\n          visited_nodes[element[0]][element[1]] = true;\n          this.check_for_letter_traversal(\n            grid,\n            word,\n            1,\n            element[0],\n            element[1],\n            visited_nodes,\n            answer\n          );\n        }\n      }\n      a++;\n    }\n    console.log(boggle_call, \"boggle_call\");\n    return answer;\n  }\n\n  render() {\n    var word_valid_list = this.boggle(\n      [\n        [\"T\", \"T\", \"N\", \"T\", \"D\"],\n        [\"H\", \"N\", \"C\", \"P\", \"R\"],\n        [\"I\", \"L\", \"A\", \"E\", \"E\"],\n        [\"G\", \"L\", \"Z\", \"R\", \"E\"],\n        [\"S\", \"R\", \"F\", \"O\", \"S\"]\n      ],\n      word_list\n    );\n    console.log(word_valid_list);\n    return <h1>My name is Swarnim</h1>;\n  }\n}\n\nexport default FindAllValidWords;\n"]},"metadata":{},"sourceType":"module"}